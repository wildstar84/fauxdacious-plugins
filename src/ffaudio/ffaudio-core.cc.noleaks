/*
 * Fauxdacious FFaudio Plugin
 * Copyright Â© 2009 William Pitcock <nenolod@dereferenced.org>
 *                  Matti HÃ¤mÃ¤lÃ¤inen <ccr@tnsp.org>
 * Copyright Â© 2011-2016 John Lindgren <john.lindgren@aol.com>
 * Video-playing capability added - copyright Â© 2015-2017 Jim Turner <turnerjw784@yahoo.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions, and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions, and the following disclaimer in the documentation
 *    provided with the distribution.
 *
 * This software is provided "as is" and without any warranty, express or
 * implied. In no event shall the authors be liable for any damages arising from
 */

#include <stdlib.h>
#include <time.h>
#include <stdio.h>
#include <string.h>
#if SDL == 2
#include <SDL.h>
#include <SDL_video.h>
#endif

#undef FFAUDIO_DOUBLECHECK  /* Doublecheck probing result for debugging purposes */
#undef FFAUDIO_NO_BLACKLIST /* Don't blacklist any recognized codecs/formats */

#include "ffaudio-stdinc.h"

#include <pthread.h>

#include <audacious/audtag.h>
#include <libaudcore/audstrings.h>
#ifdef _WIN32
#include <libaudcore/drct.h>
#endif
#include <libaudcore/i18n.h>
#include <libaudcore/multihash.h>
#include <libaudcore/runtime.h>
#include <libaudcore/playlist.h>
#include <libaudcore/preferences.h>
#include <libaudcore/probe.h>

extern "C" {
#if SDL != 2
#include <SDL_syswm.h>
#endif
#include <libswscale/swscale.h>
}

// #define SDL_AUDIO_BUFFER_SIZE 4096
// #define MAX_AUDIO_FRAME_SIZE 192000

#if SDL != 2
#ifndef _WIN32
#include <X11/Xlib.h>
#endif
#include <SDL.h>
#endif

#if CHECK_LIBAVFORMAT_VERSION (57, 33, 100, 57, 5, 0)
#define ALLOC_CONTEXT 1
#endif

#if CHECK_LIBAVCODEC_VERSION (57, 37, 100, 57, 16, 0)
#define SEND_PACKET 1
#endif

#if CHECK_LIBAVCODEC_VERSION (55, 25, 100, 55, 16, 0)
#define av_free_packet av_packet_unref
#endif

typedef struct
{
    int stream_idx;
    AVStream * stream;
    AVCodecContext * context;  // JWT:ADDED
    AVCodec * codec;
}
CodecInfo;

class FFaudio : public InputPlugin
{
public:
    static const char about[];
    static const char * const exts[], * const mimes[];

    static constexpr PluginInfo info = {
        N_("FFmpeg Plugin"),
        PACKAGE,
        about
    };

    constexpr FFaudio () : InputPlugin (info, InputInfo (FlagWritesTag)
        .with_priority (10) /* lowest priority fallback */
        .with_exts (exts)
        .with_mimes (mimes)) {}

    bool init ();
    void cleanup ();

    bool is_our_file (const char * filename, VFSFile & file);
    bool read_tag (const char * filename, VFSFile & file, Tuple & tuple, Index<char> * image);
    bool write_tuple (const char * filename, VFSFile & file, const Tuple & tuple);
    void write_audioframe (CodecInfo * cinfo, AVPacket * pkt, int out_fmt, bool planar);
#if SDL == 2
    void write_videoframe (SDL_Renderer *renderer, CodecInfo * vcinfo, 
            SDL_Texture * bmp, AVPacket *pkt, int video_width, 
            int video_height, bool last_resized, bool * windowIsStable);
#else
    void write_videoframe (SwsContext * sws_ctx, CodecInfo * vcinfo, 
            SDL_Overlay * bmp, AVPacket *pkt, int video_width, 
            int video_height, bool last_resized);
#endif
    bool play (const char * filename, VFSFile & file);
};

EXPORT FFaudio aud_plugin_instance;

static bool play_video;  /* JWT: TRUE IF USER IS CURRENTLY PLAYING VIDEO (KILLING VID. WINDOW TURNS OFF)! */
#if SDL == 2
static SDL_Window *screen;  /* JWT: MUST DECLARE VIDEO SCREEN-WINDOW HERE */
#else
#ifdef _WIN32
HWND hwnd;
#endif
#endif

struct ScopedContext
{
    AVCodecContext * ptr;
    AVCodecContext * operator-> () { return ptr; }

    ScopedContext (const CodecInfo & cinfo)
    {
#ifdef ALLOC_CONTEXT
        ptr = avcodec_alloc_context3 (cinfo.codec);
        avcodec_parameters_to_context (ptr, cinfo.stream->codecpar);
#else
        ptr = cinfo.stream->codec;
#endif
    }

#ifdef ALLOC_CONTEXT
    ~ScopedContext () { avcodec_free_context (& ptr); }
#else
    ~ScopedContext () { avcodec_close (ptr); }
#endif
};

struct ScopedPacket : public AVPacket
{
    ScopedPacket () : AVPacket ()
        { av_init_packet (this); }

#if CHECK_LIBAVCODEC_VERSION (55, 25, 100, 55, 16, 0)
    ~ScopedPacket () { av_packet_unref (this); }
#else
    ~ScopedPacket () { av_free_packet (this); }
#endif
};

struct ScopedFrame
{
#if CHECK_LIBAVCODEC_VERSION (55, 45, 101, 55, 28, 1)
    AVFrame * ptr = av_frame_alloc ();
#else
    AVFrame * ptr = avcodec_alloc_frame ();
#endif

    AVFrame * operator-> () { return ptr; }

#if CHECK_LIBAVCODEC_VERSION (55, 45, 101, 55, 28, 1)
    ~ScopedFrame () { av_frame_free (& ptr); }
#elif CHECK_LIBAVCODEC_VERSION (54, 59, 100, 54, 28, 0)
    ~ScopedFrame () { avcodec_free_frame (& ptr); }
#else
    ~ScopedFrame () { av_free (ptr); }
#endif
};

/* 
    JWT: ADDED ALL THIS QUEUE STUFF TO SMOOTH VIDEO PERFORMANCE SO THAT VIDEO FRAMES WOULD 
    BE OUTPUT MORE INTERLACED WITH THE AUDIO FRAMES BY QUEUEING VIDEO FRAMES UNTIL AN 
    AUDIO FRAME IS PROCESSED, THEN DEQUEUEING AND PROCESSING 'EM WITH EACH AUDIO FRAME.  
    THE SIZE OF THIS QUEUE IS SET BY video_qsize CONFIG PARAMETER AND DEFAULTS TO 8.
    HAVING TOO MANY CAN RESULT IN DELAYED VIDEO, SO EXPERIMENT.  IDEALLY, PACKETS SHOULD 
    BE PROCESSED:  V A V A V A..., BUT THIS HANDLES:  
    V1 V2 V3 V4 V5 A1 A2 A3 A4 A5 A6 A7 V7 A8... AS: 
    (q:V1 V2 V3 V4 V5 V6) A1 A2 dq:V1 A3 A4 dq:V2 A5 A6 dq:V3 A7 A8...
    WE DON'T WANT TO INTERRUPT AUDIO PERFORMANCE AND I DON'T KNOW HOW TO THREAD IT UP,
    BUT THIS SIMPLE APPROACH SEEMS TO WORK PRETTY SMOOTH FOR ME!  OTHERWISE TRY 
    INCREASING video_qsize IN config file OTHERWISE.
    BORROWED THESE FUNCTIONS FROM:
    http://www.thelearningpoint.net/computer-science/data-structures-queues--with-c-program-source-code
*/

typedef struct 
{
    int capacity;
    int size;
    int front;
    int rear;
    AVPacket *elements;
}
pktQueue;

pktQueue * createQueue (int maxElements)
{
    /* Create a Queue */
    pktQueue *Q;
    Q = (pktQueue *) malloc (sizeof (pktQueue));
    /* Initialise its properties */
    Q->elements = (AVPacket *) malloc (sizeof (AVPacket) * maxElements);
    Q->size = 0;
    Q->capacity = maxElements;
    Q->front = 0;
    Q->rear = -1;
    /* Return the pointer */
    return Q;
}

bool Dequeue (pktQueue *Q)
{
    /* If Queue size is zero then it is empty. So we cannot pop */
    if (Q->size==0)
        return false;
    /* Removing an element is equivalent to incrementing index of front by one */
    else
    {
        Q->size--;
        if (Q->elements[Q->front].data)
            av_free_packet (&Q->elements[Q->front]);

        Q->front++;
        /* As we fill elements in circular fashion */
        if (Q->front==Q->capacity)
            Q->front=0;
    }
    return true;
}

/* JWT:FLUSH AND FREE EVERYTHING IN THE QUEUE */
void QFlush (pktQueue *Q)
{
    while (Q->size > 0)
    {
        Q->size--;
        if (Q->elements[Q->front].data)
            av_free_packet (&Q->elements[Q->front]);

        Q->front++;
        /* As we fill elements in circular fashion */
        if (Q->front==Q->capacity)
            Q->front=0;
    }

}

AVPacket * QFront (pktQueue *Q)
{
    if (Q->size==0)
    {
        AUDDBG ("Queue is Empty\n");
        return nullptr;
    }
    /* Return the element which is at the front*/
    return &Q->elements[Q->front];
}

bool Enqueue (pktQueue *Q, AVPacket element)
{
    /* If the Queue is full, we cannot push an element into it as there is no space for it.*/
    if (Q->size == Q->capacity)
    {
        AUDDBG ("Queue is Full\n");
        return false;
    }
    else
    {
        Q->size++;
        Q->rear = Q->rear + 1;
        /* As we fill the queue in circular fashion */
        if (Q->rear == Q->capacity)
            Q->rear = 0;
        /* Insert the element in its rear side */ 
        Q->elements[Q->rear] = element;
    }
    return true;
}

void destroyQueue (pktQueue *Q)
{
    QFlush (Q);
    free (Q->elements);
    free (Q);
    Q = nullptr;
}

/* JWT:END OF ADDED VIDEO PACKET QUEUEING FUNCTIONS */

static SimpleHash<String, AVInputFormat *> extension_dict;

static void create_extension_dict ();

static int lockmgr (void * * mutexp, enum AVLockOp op)
{
    switch (op)
    {
    case AV_LOCK_CREATE:
        * mutexp = new pthread_mutex_t;
        pthread_mutex_init ((pthread_mutex_t *) * mutexp, nullptr);
        break;
    case AV_LOCK_OBTAIN:
        pthread_mutex_lock ((pthread_mutex_t *) * mutexp);
        break;
    case AV_LOCK_RELEASE:
        pthread_mutex_unlock ((pthread_mutex_t *) * mutexp);
        break;
    case AV_LOCK_DESTROY:
        pthread_mutex_destroy ((pthread_mutex_t *) * mutexp);
        delete (pthread_mutex_t *) * mutexp;
        break;
    }

    return 0;
}

static void ffaudio_log_cb (void * avcl, int av_level, const char * fmt, va_list va)
{
    audlog::Level level = audlog::Debug;
    char message [2048];

    switch (av_level)
    {
    case AV_LOG_QUIET:
        return;
    case AV_LOG_PANIC:
    case AV_LOG_FATAL:
    case AV_LOG_ERROR:
        level = audlog::Error;
        break;
    case AV_LOG_WARNING:
        level = audlog::Warning;
        break;
    case AV_LOG_INFO:
        level = audlog::Info;
        break;
    default:
        break;
    }

    AVClass * avc = avcl ? * (AVClass * *) avcl : nullptr;

    vsnprintf (message, sizeof message, fmt, va);

    audlog::log (level, __FILE__, __LINE__, avc ? avc->item_name (avcl) : __FUNCTION__,
                 "<%p> %s", avcl, message);
}

bool FFaudio::init ()
{
    AUDINFO ("Starting up FFaudio (and SDL).\n");
#if SDL == 2
    /* JWT:FIXME:  THIS *MUST* BE DONE *EARLY* AT STARTUP (SO THAT IT'S DONE IN THE *MAIN* THREAD
        otherwise SEGFAULTS IF A GTK WINDOW (ie. playlist or about) IS OPENED LATER!
        (WE NEED TO FIGURE OUT HOW TO CALL SDL2_CreateWindow () IN THE "MAIN" THREAD?!) 
        SEE ALSO:  libaudcore/plugin-registry.cc!
        NOTE:  WE ALSO DO SDL_INIT_AUDIO HERE TOO (INSTEAD OF IN sdlout.cc)
    */
    screen = nullptr;
    play_video = false;
    if (SDL_Init (SDL_INIT_AUDIO | SDL_INIT_VIDEO) < 0)
    {
        AUDERR ("Failed to init SDL (no video playing): %s.\n", SDL_GetError ());
        aud_set_bool ("ffaudio", "play_video", false);
    }
    else
    {
        Uint32 flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;
    	   if (aud_get_bool ("ffaudio", "allow_highdpi"))
    	       flags |= SDL_WINDOW_ALLOW_HIGHDPI;

        screen = SDL_CreateWindow ("Fauxdacious Video", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 
            1, 1, flags);
        if (! screen)
        {
            AUDERR ("Failed to create SDL window (no video playing): %s.\n", SDL_GetError ());
            aud_set_bool ("ffaudio", "play_video", false);
        }
#ifdef _WIN32
        SDL_SetHint (SDL_HINT_VIDEO_X11_NET_WM_PING, "0");
#endif
    }
#else
    if (SDL_Init (SDL_INIT_AUDIO) < 0)
        AUDERR ("Failed to init SDL (audio): %s.\n", SDL_GetError ());
#endif
    
    av_register_all ();
    av_lockmgr_register (lockmgr);

    create_extension_dict ();

    av_log_set_callback (ffaudio_log_cb);

    return true;
}

void FFaudio::cleanup ()
{
    AUDINFO ("Shutting down FFaudio (and SDL).\n");
#if SDL == 2
    if (screen)
    {
        // SDL_HideWindow (screen);
        SDL_DestroyWindow (screen);
        screen = nullptr;
    }
#endif

    SDL_Quit ();
    extension_dict.clear ();

    av_lockmgr_register (nullptr);
}

static int log_result (const char * func, int ret)
{
    if (ret < 0 && ret != (int) AVERROR_EOF && ret != AVERROR (EAGAIN))
    {
        static char buf[256];
        if (! av_strerror (ret, buf, sizeof buf))
            AUDERR ("%s failed: %s\n", func, buf);
        else
            AUDERR ("%s failed\n", func);
    }

    return ret;
}

#define LOG(function, ...) log_result (#function, function (__VA_ARGS__))

static void create_extension_dict ()
{
    AVInputFormat * f;
    for (f = av_iformat_next (nullptr); f; f = av_iformat_next (f))
    {
        if (! f->extensions)
            continue;

        StringBuf exts = str_tolower (f->extensions);
        Index<String> extlist = str_list_to_index (exts, ",");

        for (auto & ext : extlist)
            extension_dict.add (ext, std::move (f));
    }
}

static AVInputFormat * get_format_by_extension (const char * name)
{
    StringBuf ext = uri_get_extension (name);
    if (! ext)
        return nullptr;

    AUDDBG ("Get format by extension: %s\n", name);
    AVInputFormat * * f = extension_dict.lookup (String (str_tolower (ext)));

    if (f && * f)
        AUDDBG ("Format %s.\n", (* f)->name);
    else
        AUDDBG ("Format unknown.\n");

    return f ? * f : nullptr;
}

static AVInputFormat * get_format_by_content (const char * name, VFSFile & file)
{
    AUDDBG ("Get format by content: %s\n", name);

    AVInputFormat * f = nullptr;

    unsigned char buf[16384 + AVPROBE_PADDING_SIZE];
    int size = 16;
    int filled = 0;
    int target = 100;
    int score = 0;

    while (1)
    {
        if (filled < size)
            filled += file.fread (buf + filled, 1, size - filled);

        memset (buf + filled, 0, AVPROBE_PADDING_SIZE);
        AVProbeData d = {name, buf, filled};
        score = target;

        f = av_probe_input_format2 (& d, true, & score);
        if (f)
            break;

        if (size < 16384 && filled == size)
            size *= 4;
        else if (target > 10)
            target = 10;
        else
            break;
    }

    if (f)
        AUDDBG ("Format %s, buffer size %d, score %d.\n", f->name, filled, score);
    else
        AUDDBG ("Format unknown.\n");

    if (file.fseek (0, VFS_SEEK_SET) < 0)
        ; /* ignore errors here */

    return f;
}

static AVInputFormat * get_format (const char * name, VFSFile & file)
{
    AVInputFormat * f = get_format_by_extension (name);
    return f ? f : get_format_by_content (name, file);
}

static AVFormatContext * open_input_file (const char * name, VFSFile & file)
{
    AVInputFormat * f = get_format (name, file);

    if (! f)
    {
        AUDERR ("Unknown format for %s.\n", name);
        return nullptr;
    }

    AVFormatContext * c = avformat_alloc_context ();
    AVIOContext * io = io_context_new (file);
    c->pb = io;

    if (LOG (avformat_open_input, & c, name, f, nullptr) < 0)
    {
        io_context_free (io);
        return nullptr;
    }

    return c;
}

static void close_input_file (AVFormatContext * c)
{
    AVIOContext * io = c->pb;

    avformat_close_input (&c);
    io_context_free (io);
}

static bool find_codec (AVFormatContext * c, CodecInfo * cinfo)
{
    avformat_find_stream_info (c, nullptr);

    for (unsigned i = 0; i < c->nb_streams; i++)
    {
        AVStream * stream = c->streams[i];

#ifndef ALLOC_CONTEXT
#define codecpar codec
AUDERR("ALLOC_CONTEXT IS TRUE!\n");
#endif
        if (stream && stream->codecpar && stream->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)
        {
            AVCodec * codec = avcodec_find_decoder (stream->codecpar->codec_id);

            if (codec)
            {
                cinfo->stream_idx = i;
                cinfo->stream = stream;
                cinfo->codec = codec;
#ifdef ALLOC_CONTEXT
        cinfo->context = avcodec_alloc_context3 (cinfo->codec);
        avcodec_parameters_to_context (cinfo->context, stream->codecpar);
#else
        cinfo->context = stream->codec;  // AVCodecContext *
#endif

                return true;
            }
        }
#undef codecpar
    }

    return false;
}

bool FFaudio::is_our_file (const char * filename, VFSFile & file)
{
    return (bool) get_format (filename, file);
}

static const struct {
    Tuple::ValueType ttype;  /* Tuple field value type */
    Tuple::Field field;      /* Tuple field constant */
    const char * keys[5];    /* Keys to match (case-insensitive), ended by nullptr */
} metaentries[] = {
    {Tuple::String, Tuple::Artist, {"author", "hor", "artist", nullptr}},
    {Tuple::String, Tuple::Title, {"title", "le", nullptr}},
    {Tuple::String, Tuple::Album, {"album", "WM/AlbumTitle", nullptr}},
    {Tuple::String, Tuple::Performer, {"performer", nullptr}},
    {Tuple::String, Tuple::Copyright, {"copyright", nullptr}},
    {Tuple::String, Tuple::Genre, {"genre", "WM/Genre", nullptr}},
    {Tuple::String, Tuple::Comment, {"comment", nullptr}},
    {Tuple::String, Tuple::Composer, {"composer", nullptr}},
    {Tuple::Int, Tuple::Year, {"year", "WM/Year", "date", nullptr}},
    {Tuple::Int, Tuple::Track, {"track", "WM/TrackNumber", nullptr}},
};

static void read_metadata_dict (Tuple & tuple, AVDictionary * dict)
{
    for (auto & meta : metaentries)
    {
        AVDictionaryEntry * entry = nullptr;

        for (int j = 0; ! entry && meta.keys[j]; j ++)
            entry = av_dict_get (dict, meta.keys[j], nullptr, 0);

        if (entry && entry->value)
        {
            if (meta.ttype == Tuple::String)
                tuple.set_str (meta.field, entry->value);
            else if (meta.ttype == Tuple::Int)
                tuple.set_int (meta.field, atoi (entry->value));
        }
    }
}

bool FFaudio::read_tag (const char * filename, VFSFile & file, Tuple & tuple, Index<char> * image)
{
    SmartPtr<AVFormatContext, close_input_file>
     ic (open_input_file (filename, file));

    if (! ic)
        return false;

    CodecInfo cinfo;
    if (! find_codec (ic.get (), & cinfo))
        return false;

    tuple.set_int (Tuple::Length, ic->duration / 1000);
    tuple.set_int (Tuple::Bitrate, ic->bit_rate / 1000);

    if (cinfo.codec->long_name)
        tuple.set_str (Tuple::Codec, cinfo.codec->long_name);

    if (ic->metadata)
        read_metadata_dict (tuple, ic->metadata);
    if (cinfo.stream->metadata)
        read_metadata_dict (tuple, cinfo.stream->metadata);

    if (! file.fseek (0, VFS_SEEK_SET))
        audtag::read_tag (file, tuple, image);

#if CHECK_LIBAVFORMAT_VERSION (54, 2, 100, 54, 2, 0)
    if (image && ! image->len ())
    {
        for (unsigned i = 0; i < ic->nb_streams; i ++)
        {
            if (ic->streams[i]->attached_pic.size > 0)
            {
                image->insert ((char *) ic->streams[i]->attached_pic.data, 0,
                 ic->streams[i]->attached_pic.size);
                break;
            }
        }
    }
#endif

#ifdef ALLOC_CONTEXT
    avcodec_free_context (& cinfo.context);
#else
    avcodec_close (cinfo.context);
#endif
    av_free(cinfo.context);
    cinfo.context = nullptr;
    cinfo.codec = nullptr;
    cinfo.stream = nullptr;
    return true;
}

bool FFaudio::write_tuple (const char * filename, VFSFile & file, const Tuple & tuple)
{
    if (str_has_suffix_nocase (filename, ".ape"))
        return audtag::write_tuple (file, tuple, audtag::TagType::APE);

#if SDL == 2
    return audtag::write_tuple (file, tuple, audtag::TagType::None);
#else
    /* JWT:FIXME: FOR SOME REASON ABOVE LINE WON'T COMPILE WITH SDL_syswm.h AND X11/Xlib.h INCLUDED?!?!
        "error: expected unqualified-id before numeric constant return audtag::tuple_write (tuple, file, audtag::TagType::None);"
        SO REPLACED WITH NEXT LINE:
    */
    //return audtag::write_tuple (file, tuple, audtag::TagType::ID3v2);
    return audtag::write_tuple (file, tuple, (audtag::TagType) 0);
#endif
}

static bool convert_format (int ff_fmt, int & aud_fmt, bool & planar)
{
    switch (ff_fmt)
    {
        case AV_SAMPLE_FMT_U8: aud_fmt = FMT_U8; planar = false; break;
        case AV_SAMPLE_FMT_S16: aud_fmt = FMT_S16_NE; planar = false; break;
        case AV_SAMPLE_FMT_S32: aud_fmt = FMT_S32_NE; planar = false; break;
        case AV_SAMPLE_FMT_FLT: aud_fmt = FMT_FLOAT; planar = false; break;

        case AV_SAMPLE_FMT_U8P: aud_fmt = FMT_U8; planar = true; break;
        case AV_SAMPLE_FMT_S16P: aud_fmt = FMT_S16_NE; planar = true; break;
        case AV_SAMPLE_FMT_S32P: aud_fmt = FMT_S32_NE; planar = true; break;
        case AV_SAMPLE_FMT_FLTP: aud_fmt = FMT_FLOAT; planar = true; break;

    default:
        AUDERR ("Unsupported audio format %d\n", (int) ff_fmt);
        return false;
    }

    return true;
}

void FFaudio::write_audioframe (CodecInfo * cinfo, AVPacket * pkt, int out_fmt, bool planar)
{
    int size = 0;
    Index<char> buf;
#ifdef SEND_PACKET
    if ((LOG (avcodec_send_packet, cinfo->context, pkt)) < 0)
        return;
#else
    int decoded = 0;
    int len = 0;
#endif

    while (pkt->size > 0)
    {
        ScopedFrame frame;
#ifdef SEND_PACKET
        if ((LOG (avcodec_receive_frame, cinfo->context, frame.ptr)) < 0)
            break; /* read next packet (continue past errors) */
#else
        decoded = 0;
        len = LOG (avcodec_decode_audio4, cinfo->context, frame.ptr, & decoded, pkt);
        if (len < 0)
        {
            AUDERR ("decode_audio() failed, code %d\n", len);
            break;
        }

        pkt->size -= len;
        pkt->data += len;

        if (! decoded)
        {
            if (pkt->size > 0)
                continue; /* process more of current packet */

            break;
        }
#endif
        size = FMT_SIZEOF (out_fmt) * cinfo->context->channels * frame->nb_samples;

        if (planar)
        {
            if (size > buf.len ())
                buf.resize (size);

            audio_interlace ((const void * *) frame->data, out_fmt,
                    cinfo->context->channels, buf.begin (), frame->nb_samples);
            write_audio (buf.begin (), size);
        }
        else
            write_audio (frame->data[0], size);
    }
    return;
}

/* JWT: NEW FUNCTION TO WRITE VIDEO FRAMES TO THE POPUP WINDOW: */
#if SDL == 2
void FFaudio::write_videoframe (SDL_Renderer *renderer, CodecInfo * vcinfo, 
    SDL_Texture * bmp, AVPacket *pkt, int video_width, 
    int video_height, bool last_resized, bool * windowIsStable)
{
#else
void FFaudio::write_videoframe (SwsContext * sws_ctx, CodecInfo * vcinfo, 
    SDL_Overlay * bmp, AVPacket *pkt, int video_width, 
    int video_height, bool last_resized)
{
#endif
#ifdef SEND_PACKET
    if ((LOG (avcodec_send_packet, vcinfo->context, pkt)) < 0)
        return;
#else
    int subframeCnt = 0;
    int frameFinished = 0;
    int len = 0;
    while (subframeCnt < 16)
    {
#endif
        ScopedFrame vframe;
#ifdef SEND_PACKET
        if ((LOG (avcodec_receive_frame, vcinfo->context, vframe.ptr)) < 0)
            return; /* read next packet (continue past errors) */
#else
        frameFinished = 0;
        len = LOG (avcodec_decode_video2, vcinfo->context, vframe.ptr, &frameFinished, pkt);
        /* Did we get a video frame? */
        if (len < 0)
        {
            AUDERR ("decode_video() failed, code %d\n", len);
            return;
        }
        if (frameFinished)
        {
#endif
            if (last_resized)  /* BLIT THE FRAME, BUT ONLY IF WE'RE NOT CURRENTLY RESIZING THE WINDOW! */
            {
#if SDL == 2
                SDL_UpdateYUVTexture (bmp, nullptr, vframe->data[0], vframe->linesize[0], 
                    vframe->data[1], vframe->linesize[1], vframe->data[2], vframe->linesize[2]);
                SDL_RenderCopy (renderer, bmp, nullptr, nullptr);  // USE NULL TO GET IMAGE TO FIT WINDOW!
                SDL_RenderPresent (renderer);
                (*windowIsStable) = true;
#else
                SDL_Rect rect;
                AVFrame pict = { { 0 } };
                SDL_LockYUVOverlay (bmp);
                pict.data[0] = bmp->pixels[0];
                pict.data[1] = bmp->pixels[2];
                pict.data[2] = bmp->pixels[1];
                pict.linesize[0] = bmp->pitches[0];
                pict.linesize[1] = bmp->pitches[2];
                pict.linesize[2] = bmp->pitches[1];
                /* Convert the image into YUV format that SDL uses. */
                sws_scale (sws_ctx, (uint8_t const * const *)vframe->data,
                    vframe->linesize, 0, vcinfo->context->height,
                    pict.data, pict.linesize);
                SDL_UnlockYUVOverlay (bmp);

                rect.x = 0;
                rect.y = 0;
                rect.w = video_width;
                rect.h = video_height;
                SDL_DisplayYUVOverlay (bmp, &rect);
#endif
            }
            return;
#ifndef SEND_PACKET
        }
        else
        {
            if (pkt->size <= 0 || pkt->data < 0)
                return;
            pkt->size -= len;
            pkt->data += len;
            if (pkt->size <= 0)
                return;
        }
        ++subframeCnt;
    }
    AUDERR ("w:write_videoframe: runaway frame skipped (more than 16 parts)\n");
    return;
#endif
}

/* WHEN EXITING PLAY, WE SAVE THE WINDOW-POSITION & SIZE SO WINDOW CAN POP UP IN SAME POSITION NEXT TIME! */
#if SDL == 2
void save_window_xy (SDL_Window *screen, int video_fudge_x, int video_fudge_y)
{
    int x, y, w, h;

    SDL_GetWindowPosition (screen, &x, &y);
    SDL_GetWindowSize (screen, &w, &h);
    x += video_fudge_x;  /* APPLY CALCULATED FUDGE-FACTOR */
    if (x < 0)
        x = 1;
    y += video_fudge_y;
    if (y < 0)
        y = 1;
    aud_set_int ("ffaudio", "video_window_x", x);
    aud_set_int ("ffaudio", "video_window_y", y);
    aud_set_int ("ffaudio", "video_window_w", w);
    aud_set_int ("ffaudio", "video_window_h", h);
#else
void save_window_xy ()
{
    int video_fudge_x;
    int video_fudge_y;
    int video_fudge_w;
    int video_fudge_h;
    int ii;

#ifndef _WIN32
    SDL_SysWMinfo info;
    SDL_VERSION (&info.version);
    if (SDL_GetWMInfo (&info) > 0)
    {
        int x = 0; int y = 0;
        Window chldwin;
        XWindowAttributes attr0, attr;

        ii = aud_get_int ("ffaudio", "video_fudge_x");
        video_fudge_x = ii ? ii : -1;
        ii = aud_get_int ("ffaudio", "video_fudge_y");
        video_fudge_y = ii ? ii : -1;
        video_fudge_w = aud_get_int ("ffaudio", "video_fudge_w");
        video_fudge_h = aud_get_int ("ffaudio", "video_fudge_h");
        info.info.x11.lock_func ();
        XGetWindowAttributes (info.info.x11.display, info.info.x11.wmwindow, &attr0);
        XGetWindowAttributes (info.info.x11.display, info.info.x11.window, &attr);
        XTranslateCoordinates (info.info.x11.display, info.info.x11.window, attr.root, attr.x, attr.y, &x, &y, &chldwin);
        info.info.x11.unlock_func ();
        aud_set_int ("ffaudio", "video_window_x", (x-attr0.x)+video_fudge_x);
        aud_set_int ("ffaudio", "video_window_y", (y-attr0.y)+video_fudge_y);
        aud_set_int ("ffaudio", "video_window_w", attr.width+video_fudge_w);
        aud_set_int ("ffaudio", "video_window_h", attr.height+video_fudge_h);
    }
#else
    RECT rc;

    ii = aud_get_int ("ffaudio", "video_fudge_x");
    video_fudge_x = ii ? ii : 8;
    ii = aud_get_int ("ffaudio", "video_fudge_y");
    video_fudge_y = ii ? ii : 30;
    ii = aud_get_int ("ffaudio", "video_fudge_w");
    video_fudge_w = ii ? ii : -68;
    ii = aud_get_int ("ffaudio", "video_fudge_h");
    video_fudge_h = ii ? ii : -38;
    GetWindowRect (hwnd, &rc);
    aud_set_int ("ffaudio", "video_window_x", rc.left+video_fudge_x);
    aud_set_int ("ffaudio", "video_window_y", rc.top+video_fudge_y);
    aud_set_int ("ffaudio", "video_window_w", (rc.right-rc.left)+video_fudge_w);
    aud_set_int ("ffaudio", "video_window_h", (rc.bottom-rc.top)+video_fudge_h);
#endif
#endif
}

bool FFaudio::play (const char * filename, VFSFile & file)
{
    bool codec_opened = false;     // TRUE IF SUCCESSFULLY OPENED CODECS:
    SmartPtr<AVFormatContext, close_input_file>
     ic (open_input_file (filename, file));

    if (! ic)
        return false;

    CodecInfo cinfo;
    if (! find_codec (ic.get (), & cinfo))
    {
        AUDERR ("No codec found for %s.\n", filename);
        return false;
    }

    AUDDBG("got codec %s for stream index %d, opening\n", cinfo.codec->name, cinfo.stream_idx);

//    ScopedContext context (cinfo);
    if (LOG (avcodec_open2, cinfo.context, cinfo.codec, nullptr) < 0)
        return false;

    codec_opened = true;
    int out_fmt; bool planar;
    if (! convert_format (cinfo.context->sample_fmt, out_fmt, planar))
        return false;

    /* Open audio output */
    set_stream_bitrate(ic->bit_rate);
    open_audio(out_fmt, cinfo.context->sample_rate, cinfo.context->channels);

    int errcount = 0;
    bool eof = false;

    Index<char> buf;

    while (! eof && ! check_stop ())
    {
        int seek_value = check_seek ();

        if (seek_value >= 0)
        {
            if (LOG (av_seek_frame, ic.get (), -1, (int64_t) seek_value *
             AV_TIME_BASE / 1000, AVSEEK_FLAG_ANY) >= 0)
                errcount = 0;

            seek_value = -1;
        }

        /* Read next frame (or more) of data */
        ScopedPacket pkt;
        int ret = LOG (av_read_frame, ic.get (), & pkt);

        if (ret < 0)
        {
            if (ret == (int) AVERROR_EOF)
                eof = true;
            else if (++ errcount > 4)
                return false;
            else
                continue;
        }
        else
        {
            errcount = 0;

            /* Ignore any other substreams */
            if (pkt.stream_index != cinfo.stream_idx)
                continue;
        }

        /* Decode and play packet/frame */
        /* On EOF, send an empty packet to "flush" the decoder */
        /* Otherwise, make a mutable (shallow) copy of the real packet */
        AVPacket tmp;
        if (eof) {
            tmp = AVPacket ();
            av_init_packet (& tmp);
        }
        else
            tmp = pkt;

#ifdef SEND_PACKET
        if ((ret = LOG (avcodec_send_packet, cinfo.context, & tmp)) < 0)
            return false; /* defensive, errors not expected here */
#endif

        while (! check_stop ())
        {
            ScopedFrame frame;

#ifdef SEND_PACKET
            if ((ret = LOG (avcodec_receive_frame, cinfo.context, frame.ptr)) < 0)
                break; /* read next packet (continue past errors) */
#else
            int decoded = 0;
            int len = LOG (avcodec_decode_audio4, cinfo.context, frame.ptr, & decoded, & tmp);

            if (len < 0)
                break; /* read next packet (continue past errors) */

            tmp.size -= len;
            tmp.data += len;

            if (! decoded)
            {
                if (tmp.size > 0)
                    continue; /* process more of current packet */

                break; /* read next packet */
            }
#endif

            int size = FMT_SIZEOF (out_fmt) * cinfo.context->channels * frame->nb_samples;

            if (planar)
            {
                if (size > buf.len ())
                    buf.resize (size);

                audio_interlace ((const void * *) frame->data, out_fmt,
                 cinfo.context->channels, buf.begin (), frame->nb_samples);
                write_audio (buf.begin (), size);
            }
            else
                write_audio (frame->data[0], size);
        }
    }

    if (codec_opened)
    {
AUDERR("WILL FREE CINFO.CONTEXT!\n");
#ifdef ALLOC_CONTEXT
        avcodec_free_context (& cinfo.context);
#else
        avcodec_close (cinfo.context);
#endif
        av_free(cinfo.context);
        cinfo.context = nullptr;
        cinfo.codec = nullptr;
        cinfo.stream = nullptr;
    }
    return true;
}

const char FFaudio::about[] =
 N_("Multi-format audio decoding plugin for Audacious using\n"
    "FFmpeg multimedia framework (http://www.ffmpeg.org/)\n"
    "\n"
    "Audacious plugin by:\n"
    "William Pitcock <nenolod@nenolod.net>\n"
    "Matti Hämäläinen <ccr@tnsp.org>");

const char * const FFaudio::exts[] = {
    /* musepack, SV7/SV8 */
    "mpc", "mp+", "mpp",

    /* windows media audio */
    "wma",

    /* shorten */
    "shn",

    /* atrac3 */
    "aa3", "oma",

    /* MPEG 2/4 AC3 */
    "ac3",

    /* monkey's audio */
    "ape",

    /* DTS */
    "dts",

    /* VQF */
    "vqf",

    /* MPEG-4 */
    "m4a", "mp4",

    /* WAV (there are some WAV formats sndfile can't handle) */
    "wav",

    /* Handle OGG streams (FLAC/Vorbis etc.) */
    "ogg", "oga",

    /* Opus */
    "opus",

    /* Speex */
    "spx",

    /* True Audio */
    "tta",

    /* end of table */
    nullptr
};

const char * const FFaudio::mimes[] = {"application/ogg", nullptr};
